\documentclass{jsarticle}


\usepackage{amsmath}
\usepackage{array}
\usepackage{longtable}
\usepackage[dvipdfmx]{graphicx}
\usepackage{float}
\usepackage[truedimen, margin=25mm]{geometry}
\usepackage{url}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}

\setcounter{section}{-1}

\begin{document}

\def\lstlistingname{ソースコード}

%\lstset{
%language={C},
%backgroundcolor={\color[rgb]{0.2,0.2,0}}
%commentstyle={\small\ttfamily \color[rgb]{0,0.5,0}},
%classoffset=1,
%keywordstyle={\small\bfseries \color[rgb]{0,0,1}},
%frame=shadowbox,
%framesep=5pt,
%showstringspaces=false,
%numbers=left,
%stepnumber=1,
%breaklines=true,
%tabsize=2
%}

\lstset{% 
language={C}, 
backgroundcolor={\color[rgb]{1,1,0.95}},% 
basicstyle={},% 
identifierstyle={\small},% 
commentstyle={\small\ttfamily \color[rgb]{0,0.5,0}},% 
keywordstyle={\small\bfseries \color[rgb]{0,0,1}},% 
ndkeywordstyle={\small},% 
stringstyle={\small\ttfamily}, 
frame={tb}, 
breaklines=true, 
columns=[l]{fullflexible},% 
numbers=left,% 
xrightmargin=0zw,% 
xleftmargin=3zw,% 
numberstyle={\scriptsize},% 
stepnumber=1,
showstringspaces=false,
keepspaces=true,
numbersep=1zw,% 
morecomment=[l]{//},% 
tabsize=2
} 


\title{レポート課題No.2}
\author{川口廣伊智 \\ 学籍番号:051715223}
\date{2017/07/06}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{レポートについての注意}

\subsection{各課題の解答の構成について}
まず課題の解釈をし、解答するためのプログラムを記載した。次に得られた結果を記載した。
考察すべき内容があった場合は簡単な考察も付けた。すべての課題に考察がついているわけではない。


\subsection{プログラムについて}
各課題についてその計算を行うためのプログラムを全掲した。
長ったらしいが、ソースコードの後に特に工夫した部分がどこかを記した。



\section{基本課題EX3-1}

\subsection{課題概要}

LU分解を用いて行列の行列式を計算するプログラムを作成した。


\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=LU分解を用いて行列の行列式を計算するプログラム]
{./ex3/vandermonde/calc_determinant.c}

このプログラムを用いてVandermonde行列の行列式を計算した。今回は5行5列で
\[
(x_1, x_2, x_3, x_4, x_5) = (1, 2, 3, 4, 5)
\]
のVandermonde行列を用いた。5行5列程度の行列なら手打ちで成分を書きだすこともできなくはないが、
もっと大きなサイズのVandermonde行列を作るとすると手打ちでは苦しい。なので$(x_1, x_2, \cdots, x_n)$を指定してVandermonde行列を
生成するプログラムも作成した。

\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=Vandermonde行列を生成するプログラム]
{./ex3/vandermonde/vandermonde.c}

行列のサイズが大きくなるとVandermonde行列の行列式も手計算では一苦労なのでこれも$(x_1, x_2, \cdots, x_n)$を指定して自動で計算する
プログラムを作成した。

\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=Vandermonde行列の行列式の厳密な値を計算するプログラム]
{./ex3/vandermonde/vandermonde_theo.c}

以上のプログラムを用いて数値計算した行列式と厳密な値とを比較した。

\subsection{結果}
数値計算では-288となったが、厳密な行列式の値を計算すると288となった。
数値計算した値は厳密な値と比べて符号が反転していた。



\subsection{考察(LU分解のアルゴリズム)}
符号が反転した理由は数値計算の際に用いたLU分解のアルゴリズムを考えることで理解できる。
%ピボット選択をするごとに行列式は(-1)倍になるので


\section{基本課題EX3-2}

\subsection{実験概要}
LU分解を用いてDirichlet境界条件の下での二次元Laplace方程式の解を求めるプログラムを作成した。

\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=Laplace方程式を解くための行列を求めるプログラム]
{./ex3/laplace_lu/laplace.c}

\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=LU分解でLaplace方程式の解を求めるプログラム]
{./ex3/laplace_lu/laplace_solve.c}

このプログラムを用いていくつかのメッシュ数で解の形と解の計算にかかった時間を記載した。

また解の計算にかかった時間がメッシュ数を増やしていくとどのように変わるかをグラフで分かりやすく示した。



\subsection{実験結果}
境界条件はどれも課題で与えられた通り
\[
u(0, y) = \sin{\pi y}, u(x, 0) = u(x, 1) = u(1, y) = 0
\]
とした。

\begin{figure}[H]
 \noindent
 \begin{center}
 \includegraphics[width=12cm, angle=270]{ex3/laplace_lu/plot_mesh_5.eps}
 \caption{mesh数が25の解。概形は分かりにくい。}
 \end{center}
\end{figure}

\begin{figure}[H]
 \noindent
 \begin{center}
 \includegraphics[width=12cm, angle=270]{ex3/laplace_lu/plot_mesh_10.eps}
 \caption{mesh数が100の解。}
 \end{center}
\end{figure}

\begin{figure}[H]
 \noindent
 \begin{center}
 \includegraphics[width=12cm, angle=270]{ex3/laplace_lu/plot_mesh_30.eps}
 \caption{mesh数が900の解。}
 \end{center}
\end{figure}


\begin{figure}[H]
 \noindent
 \begin{center}
 \includegraphics[width=12cm, angle=270]{ex3/laplace_lu/plot_mesh_50.eps}
 \caption{mesh数が2500の解。}
 \end{center}
\end{figure}


\subsection{考察}



\section{基本課題EX3-3}

\subsection{実験概要}

\subsection{実験結果}

\subsection{考察}



\section{応用課題EX3-1}

\subsection{実験概要}
pointer.cのソースコードを見て出力される結果を予想し、実際にコンパイルして得た出力と比較した。

まず、ベクトルの方について予想される出力を考え、結果と比較する。行列の方についても同様にする。


\subsection{実験結果}
pointer.cのソースコードはこのようであった。



\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=pointer.c]
{./../computer-experiments/exercise/linear_system/pointer.c}

6行目でvがポインタ変数として定義されている。

15行目のプリント関数はvを出力している。vはv[0]のアドレスを表すので
出力されるのはv[0]のアドレス(具体的にはわからない)であるはずだ。

16行目は\&v[0]を出力している。\&v[0]はv[0]が格納されているアドレスを表すので
出力されるのは15行目と同じv[0]のアドレスであるはずだ。ただしアドレスは具体的にはわからないし、プログラムの実行環境によって異なる。

18行目はv+2を出力している。v+2はv[2]のアドレスを表すので
出力されるのはv[2]のアドレスである。*vはdouble型で定義されていたので8byteである。
なのでv[0]のアドレスに16を足したものが出力される。

19行目は\&v[2]を出力している。\&v[2]はv[2]が格納されているアドレスを表すので
出力されるのは18行目と同じv[2]のアドレスである。

21行目は*vを出力している。*vはvのアドレスに格納されている数値を表すので
出力されるのはv[0]の値である。出力の表示桁数の指定が\%10.5fになっているので
出力は全体の桁数が最大で10、小数点以下の桁数が最大5である。
なので出力は0.00000である。(数値の出力は以下もこれと同じ理由で小数点以下5桁まで表示される。)

22行目はv[0]を出力している。これは取りも直さずv[0]の値を表すので
出力されるのは21行目と同じ0.00000である。

24行目は*(v+2)を出力している。*(v+2)はアドレスv+2に格納されている数値を表すので
出力されるのじゃv[2]、すなわち2.00000である。

25行目はv[2]を出力している。これは取りも直さずv[2]の値なので
出力は2.00000である。

27行目は(v+2)[3]を出力している。これはアドレスv+2から3つ(24バイト)進んだ先のアドレスに格納されている
値を表すので、出力されるのはv[5]、すなわち5.00000である。

28行目は*(v+2+3)を出力している。これはアドレスv+5に格納されている値を表すので
出力はv[5]す、すなわち5.00000である。

次に行列のテストについても同様に出力を予想する。

7行目でmがポインタ変数(ポインタのポインタ変数)として定義されている。


39行目はmを出力している。これはm[0]のアドレスを表すので
出力されるのはm[0]のアドレス。

40行目は\&m[0]を出力している。\&m[0]はm[0]のアドレスを表す。
出力されるのはm[0]のアドレス。

42行目はm[0]を出力している。これはm[0][i]の配列の先頭アドレス、
すなわちm[0][0]のアドレスを表す。なので出力されるのはm[0][0]のアドレス。

43行目は\&m[0][0]を出力している。これはm[0][0]のアドレスを表すので
出力されるのはm[0][0]のアドレス。

45行目はm[2]を出力している。m[2]はm[2][i]の配列の先頭アドレスを表す。
なので出力されるのはm[2][0]のアドレスで配列はdouble型で定義されていて(8byte)、
配列のサイズが10なので
このアドレスはm[0][0]のアドレスに160を足したものになると考えられる。

46行目は\&m[2][0]を出力している。これはm[2][0]のアドレスを表すので
出力されるのはm[2][0]のアドレス。

48行目はm+2を出力している。これはm[2]のアドレスをあらわすので
出力されるのはm[2]のアドレスである。またこれは配列の定義から
m[0]のアドレスに16を足したものになると考えられる。

49行目は\&m[2]を出力している。これはm[2]のアドレスを表すので
出力されるのはm[2]のアドレス。

51行目は(*(m+2))[3]を出力している。ちょっと複雑なので丁寧に考える。
まず、m+2はm[2]のアドレスを表すのであった。そして*をポインタ変数に作用させると
そのアドレスに格納されている値を返すのであった。なので
と考えることができて、出力されるのはm[2][3]つまり203.00000である。

52行目は*(*(m+2)+3)を出力している。これも丁寧に考える。
まず*(m+2)はm[2]に格納されている値つまりm[2][0]のアドレスを表している。
ここでvがポインタ変数であるとするとv+2はv[2]のアドレスを表す。
なのでm[2]+3はm[2][3]のアドレスを表す。同じくvがポインタ変数だとすると*vはvに格納されている値を表すので
*(m[2]+3)はm[2][3]を表す。よって出力されるのはm[2][3]の値、すなわち203.00000である。

53行目はm[2][3]を出力している。これは取りも直さずm[2][3]の値なので
出力されるのは203.00000である。

55行目は*(m+2)[3]を出力している。間接演算子*より添え字演算子[3]の方が優先順位が高い。
なのでまず(m+2)[3]について考える。m[3]はm+3を表すのだから(m+2)[3]はm+5、つまりm[5]を表す。
m[5]はm[5][i]の先頭アドレス、つまりm[5][0]のアドレスを表すので
出力されるのは500.00000である。

56行目は*((m+2)[3])を出力している。(m+2)[3]はm[5]のことである。
m[5]はm[5][0]のアドレスを表すので
出力されるのはm[5][0]、つまり500.00000である。

57行目は*(m[5])を出力している。これはアドレスm[5]に格納されている値を表す。
m[5]はm[5][0]のアドレスなので
出力されるのは500.00000である。

58行目はm[5][0]を出力している。これは取りも直さずm[5][0]の値を表すので
出力されるのは500.00000である。

以上が予想される出力である。

実際にpointer.cを走らせて得られた出力をまとめた。


\begin{table}[H]
 \begin{center}
  \caption{最大次数と残差}
  \begin{tabular}{|c|r|}
   \hline
  変数 & 出力結果   \\ 
   \hline \hline
v     & 25769804768 \\
\hline
\&v[0] & 25769804768 \\
\hline
(v+2) & 25769804784 \\
\hline
\&v[2] & 25769804784 \\
\hline
*v       &    0.00000 \\
\hline
v[0]     &    0.00000 \\
\hline
*(v+2)   &    2.00000 \\
\hline
v[2]     &    2.00000 \\
\hline
(v+2)[3] &    5.00000 \\
\hline
*(v+2+3) &    5.00000 \\
\hline
m        & 25769804768 \\
\hline
\&m[0]    & 25769804768 \\
\hline
m[0]     & 25770100688 \\
\hline
\&m[0][0] & 25770100688 \\
\hline
m[2]     & 25770100848 \\
\hline
\&m[2][0] & 25770100848 \\
\hline
m+2      & 25769804784 \\
\hline
\&m[2]    & 25769804784 \\
\hline
(*(m+2))[3] &  203.00000 \\
\hline
*(*(m+2)+3) &  203.00000 \\
\hline
m[2][3]     &  203.00000 \\
\hline
*(m+2)[3]   &  500.00000 \\
\hline
*((m+2)[3]) &  500.00000 \\
\hline
*(m[5])     &  500.00000 \\
\hline
m[5][0]     &  500.00000 \\
\hline
  \end{tabular}
 \end{center}
\end{table}

結果は予想と一致していた。

\section{応用課題EX3-2}

\section{基本課題EX3-3}



\section{基本課題EX4-1}

\subsection{実験概要}
べき乗法を用いて最大固有値を計算するプログラムを作成し
成分が$v_{ij}=min(i, j)(1 \leq i \leq n, 1 \leq j \leq n)のn \times n 対称行列の固有値を求めた。$

%\lstinputlisting[basicstyle=\ttfamily, frame=single, caption=pointer.c]
%{./ex4/power_iteration/power_iteration.c}


\subsection{実験結果}

\subsection{考察}



\section{基本課題EX4-2}

\subsection{実験概要}
ファイルmeasurement.datに収められている実験データを最小二乗法により任意の次数の多項式でフィッティングできるプログラムを作成した。
このプログラムを用いて多項式の最大次数を変えた時に最も良いと考えられる最大次数を推定した。
最後にその最良の最大次数の多項式を用いて実験データをフィッティングした。

\subsection{実験結果}
まず多項式の最良の最大次数を推定した。推定するにあたっては、各最大次数の多項式について実験データとの残差を
計算し最も残差の小さい最大次数を最良であると判断した。

以下が各最大次数に対して計算した残差の表である。

\begin{table}[H]
 \begin{center}
  \caption{最大次数と残差}
  \begin{tabular}{|c|l|c|}
   \hline
   次数 & 多項式 &  残差  \\ 
   \hline \hline
   1 & 2.209534  + -0.708812 $x^1$ & 482.670215 \\
   \hline
   2 & 0.555836  + 0.318843 $x^1$  + -0.102766 $x^2$ & 270.283764 \\
   \hline
   3 & 0.417774  + 0.500040 $x^1$  + -0.148841 $x^2$  + 0.003072 $x^3$ & 259.532303  \\
   \hline
   4 &  0.527741  + 0.240453 $x^1$  + -0.027370 $x^2$  + -0.016031 $x^3$  + 0.000955 $x^4$ & 266.388636 \\
   \hline
   5 &  0.514604  + 0.291929 $x^1$  + -0.065848 $x^2$  + -0.005524 $x^3$  + -0.000236 $x^4$  + 0.000048 $x^5$ & 265.740389 \\
   \hline
   6 & 0.530055  + 0.195282 $x^1$  + 0.040494 $x^2$  + -0.049690 $x^3$  + 0.008180 $x^4$  + -0.000697 $x^5$  + 0.000025 $x^6$ & 266.299869  \\
   \hline
  \end{tabular}
 \end{center}
\end{table}


\subsection{考察}


\section{応用課題EX4-1}

\subsection{実験概要}

\subsection{実験結果}

\subsection{考察}

\section{応用課題EX4-2}

\subsection{実験概要}

特異値分解のサンプルプログラム(svd.c)をコンパイルし、入力matrix2.datを用いて
プログラムを実行した。

\subsection{実験結果}

得られた出力をそのまま記載する。

\begin{lstlisting}[basicstyle=\ttfamily, frame=single, caption=pointer.c]
Matrix A:
4 3
   1.00000    2.00000    3.00000
   6.00000    4.00000    5.00000
   8.00000    9.00000    7.00000
  10.00000   11.00000   12.00000
Result of SVD U:
4 3
  -0.13801   -0.61647   -0.05283
  -0.34037    0.37028    0.81421
  -0.54626    0.53543   -0.57516
  -0.75280   -0.44293    0.05891
Result of SVD S:
3
  25.34681    2.14879    1.70929
Result of SVD Vt:
3 3
  -0.55543   -0.58526   -0.59074
   0.67915    0.09067   -0.72838
   0.47986   -0.80576    0.34712
Reconstruction of the original matrix A:
4 3
   1.00000    2.00000    3.00000
   6.00000    4.00000    5.00000
   8.00000    9.00000    7.00000
  10.00000   11.00000   12.00000
Rank (r-1) approximation of A:
4 3
   1.04333    1.92724    3.03134
   5.33218    5.12139    4.51691
   8.47175    8.20785    7.34126
   9.95168   11.08113   11.96505
\end{lstlinsting}


講義L4の例が再現されていることが確認できた。(有効桁数は異なるが)



\subsection{考察}

\section{応用課題EX4-3}

\subsection{実験概要}

\subsection{実験結果}

\subsection{考察}

\section{応用課題EX4-4}

\subsection{実験概要}

\subsection{実験結果}

\subsection{考察}

\begin{thebibliography}{9}

\item
 増原英彦+東京大学情報教育連絡会『情報科学入門 Rubyを使って学ぶ』(東京大学出版会, 2010)


\item
 \url{http://www.cp.cmc.osaka-u.ac.jp/~kikuchi/texts/conservation.pdf}


\end{thebibliography}

\end{document}
